{
  "version": 3,
  "sources": ["../src/transform.ts", "../src/generate.ts", "../web/grids.ts"],
  "sourcesContent": ["import {\n  Dir2D,\n  Dir3D,\n  Input2D,\n  Input3D,\n  Match,\n  Match2D,\n  Match3D,\n  Model,\n  Point2D,\n  Point3D,\n  Rule,\n  ValidModel,\n  ValidModel2D,\n  ValidModel3D,\n} from './types'\n\nexport function validateGrid(model: Model) {\n  for (let i = 0; i < model.rules.length; i++) {\n    const rules = model.rules[i]\n    if (typeof rules === 'string') {\n      model.rules[i] = rules.replace(/\\s+/, ' ')\n      continue\n    }\n  }\n\n  if (model.type === '2d') {\n    const length = model.grid.input[0].length\n    for (const input of model.grid.input) {\n      if (input.length !== length) {\n        throw new Error('2D grid is not uniform')\n      }\n    }\n  }\n\n  if (model.type === '3d') {\n    const length = model.grid.input[0][0].length\n    for (const y of model.grid.input)\n      for (const input of y) {\n        if (input.length !== length) {\n          throw new Error('3D grid is not uniform')\n        }\n      }\n  }\n}\n\nexport function applyRule(model: ValidModel, { from, to }: Rule, match: Match) {\n  if (model.type === '2d') {\n    const start = { x: match.x, y: match.y }\n    let curr: Point2D | undefined\n\n    for (let i = 0; i < from.length; i++) {\n      let char = to[i]\n      curr = !curr ? { ...start } : next2D(model.grid.input, start, curr, match.dir as Dir2D, char)!\n      if (isYshift(char)) char = to[++i]\n\n      model.grid.input[curr.y] = replace(model.grid.input[curr.y], curr.x, char)\n    }\n\n    return\n  }\n\n  const start = { x: match.x, y: match.y, z: (match as Match3D).z }\n  let curr: Point3D | undefined\n\n  for (let i = 0; i < from.length; i++) {\n    let char = to[i]\n    curr = !curr ? { ...start } : next3D(model.grid.input, start, curr, match.dir as Dir3D, char)!\n    if (isYshift(char)) char = to[++i]\n\n    model.grid.input[curr.z][curr.y] = replace(model.grid.input[curr.z][curr.y], curr.x, char)\n  }\n\n  return\n}\n\nexport function findMatches(model: ValidModel, rule: Rule): Match[] {\n  const matches: Match[] = []\n  if (model.type === '2d') {\n    for (let y = 0; y < model.grid.input.length; y++) {\n      for (let x = 0; x < model.grid.input[0].length; x++) {\n        matches.push(...findMatchesAt2D(model, rule, x, y))\n      }\n    }\n\n    return matches\n  }\n\n  for (let z = 0; z < model.grid.input.length; z++) {\n    for (let y = 0; y < model.grid.input[0].length; y++) {\n      for (let x = 0; x < model.grid.input[0][0].length; x++) {\n        matches.push(...findMatchesAt3D(model, rule, x, y, z))\n      }\n    }\n  }\n  return matches\n}\n\nconst DIR_2D: Dir2D[] = ['x+1', 'x-1', 'y+1', 'y-1']\nconst DIR_3D: Dir3D[] = ['x+1', 'x-1', 'y+1', 'y-1', 'z+1', 'z-1']\n\nfunction findMatchesAt2D(model: ValidModel2D, { from }: Rule, x: number, y: number) {\n  const matches: Match2D[] = []\n  const start = { x, y }\n\n  for (const dir of DIR_2D) {\n    let curr: Point2D | undefined\n    let matched = true\n\n    for (let i = 0; i < from.length; i++) {\n      let char = from[i]\n\n      curr = !curr ? { x, y } : next2D(model.grid.input, start, curr, dir, char)\n\n      if (!curr) {\n        matched = false\n        break\n      }\n\n      if (isYshift(char)) char = from[++i]\n\n      if (model.unions[char] && model.unions[char].has(model.grid.input[curr.y][curr.x])) {\n        continue\n      }\n\n      if (char !== '*' && char !== model.grid.input[curr.y][curr.x]) {\n        matched = false\n        break\n      }\n    }\n\n    if (matched) matches.push({ x, y, dir })\n  }\n\n  return matches\n}\n\nfunction findMatchesAt3D(model: ValidModel3D, { from }: Rule, x: number, y: number, z: number) {\n  const matches: Match3D[] = []\n  const start = { x, y, z }\n\n  for (const dir of DIR_3D) {\n    let curr: Point3D | undefined\n    let matched = true\n\n    for (let i = 0; i < from.length; i++) {\n      let char = from[i]\n      curr = !curr ? { x, y, z } : next3D(model.grid.input, start, curr, dir, char)\n\n      if (!curr) {\n        matched = false\n        break\n      }\n\n      if (isYshift(char)) char = from[++i]\n\n      if (model.unions[char] && !model.unions[char].has(model.grid.input[curr.z][curr.y][curr.x])) {\n        matched = false\n        break\n      }\n\n      if (char !== '*' && char !== model.grid.input[curr.z][curr.y][curr.x]) {\n        matched = false\n        break\n      }\n    }\n\n    if (matched) matches.push({ x, y, z, dir })\n  }\n\n  return matches\n}\n\nfunction next2D(\n  inputs: Input2D,\n  start: Point2D,\n  curr: Point2D,\n  dir: Dir2D,\n  char: string\n): Point2D | undefined {\n  let point: Point2D | undefined\n\n  if (isYshift(char)) {\n    point = shift2D(start, curr, dir)\n  }\n\n  if (!point) {\n    switch (dir) {\n      case 'x-1': {\n        point = { x: curr.x - 1, y: curr.y }\n        break\n      }\n\n      case 'x+1': {\n        point = { x: curr.x + 1, y: curr.y }\n        break\n      }\n\n      case 'y-1': {\n        point = { x: curr.x, y: curr.y - 1 }\n        break\n      }\n\n      case 'y+1': {\n        point = { x: curr.x, y: curr.y + 1 }\n        break\n      }\n    }\n  }\n\n  if (point.x < 0 || point.y < 0 || point.x >= inputs[0].length || point.y >= inputs.length) return\n\n  return point\n}\n\nfunction shift2D(start: Point2D, curr: Point2D, dir: Dir2D) {\n  let point: Point2D\n\n  switch (dir) {\n    case 'x-1':\n      point = { x: start.x, y: curr.y - 1 }\n      break\n\n    case 'x+1':\n      point = { x: start.x, y: curr.y + 1 }\n      break\n\n    case 'y-1':\n      point = { x: curr.x + 1, y: start.y }\n      break\n\n    case 'y+1':\n      point = { x: curr.x - 1, y: start.y }\n      break\n  }\n\n  return point\n}\n\nfunction next3D(\n  inputs: Input3D,\n  start: Point3D,\n  curr: Point3D,\n  dir: Dir3D,\n  char: string\n): Point3D | undefined {\n  let point: Point3D | undefined\n\n  if (isYshift(char)) {\n    point = shiftY3d(start, curr, dir)\n  } else if (isZshift(char)) {\n    point = shiftZ3d(start, curr, dir)\n  }\n\n  switch (dir) {\n    case 'x-1': {\n      point = { x: curr.x - 1, y: curr.y, z: curr.z }\n      break\n    }\n\n    case 'x+1': {\n      point = { x: curr.x + 1, y: curr.y, z: curr.z }\n      break\n    }\n\n    case 'y-1': {\n      point = { x: curr.x, y: curr.y - 1, z: curr.z }\n      break\n    }\n\n    case 'y+1': {\n      point = { x: curr.x, y: curr.y + 1, z: curr.z }\n      break\n    }\n\n    case 'z-1': {\n      point = { x: curr.x, y: curr.y, z: curr.z - 1 }\n      break\n    }\n\n    case 'z+1': {\n      point = { x: curr.x, y: curr.y, z: curr.z + 1 }\n      break\n    }\n  }\n\n  return isInBounds3D(inputs, point) ? point : undefined\n}\n\nfunction isInBounds3D(inputs: Input3D, point: Point3D) {\n  if (\n    point.x < 0 ||\n    point.y < 0 ||\n    point.z < 0 ||\n    point.x >= inputs[0][0].length ||\n    point.y >= inputs[0].length ||\n    point.z >= inputs.length\n  )\n    return false\n  return true\n}\n\nfunction shiftZ3d(start: Point3D, curr: Point3D, dir: Dir3D): Point3D {\n  switch (dir) {\n    case 'x-1':\n      return { x: start.x, y: curr.y, z: curr.z - 1 }\n    case 'x+1':\n      return { x: start.x, y: curr.y, z: curr.z + 1 }\n    case 'y-1':\n      return { x: curr.x, y: start.y, z: curr.z - 1 }\n    case 'y+1':\n      return { x: curr.x, y: start.y, z: curr.z + 1 }\n    case 'z-1':\n      return { x: curr.x + 1, y: curr.y, z: start.x }\n    case 'z+1':\n      return { x: curr.x - 1, y: curr.y, z: start.x }\n  }\n}\n\nfunction shiftY3d(start: Point3D, curr: Point3D, dir: Dir3D): Point3D {\n  switch (dir) {\n    case 'x-1':\n      return { x: start.x, y: curr.y - 1, z: curr.z }\n\n    case 'x+1':\n      return { x: start.x, y: curr.y + 1, z: curr.z }\n\n    case 'y-1':\n      return { x: curr.x + 1, y: start.y, z: curr.z }\n\n    case 'y+1':\n      return { x: curr.x - 1, y: start.y, z: curr.z }\n\n    case 'z-1':\n      return { x: curr.x, y: curr.y - 1, z: start.z }\n\n    case 'z+1':\n      return { x: curr.x, y: curr.y + 1, z: start.z }\n  }\n}\n\nfunction replace(text: string, pos: number, char: string) {\n  if (char === '*') char = text[pos]\n  return text.slice(0, pos) + char + text.slice(pos + 1)\n}\n\nfunction isZshift(text: string): text is ' ' {\n  return text === ' '\n}\n\nfunction isYshift(text: string): text is '/' {\n  return text === '/'\n}\n", "import { applyRule, findMatches, validateGrid } from './transform'\nimport { Model, OnDone as ModelCallback, Rule, Sequence, Steps, ValidModel } from './types'\n\nlet ID = 0\n\nexport function generate(opts: Model) {\n  validateGrid(opts)\n  const model: ValidModel = { ...opts, ...processSequences(opts.rules), count: 0, rule: -1, id: 0 }\n\n  for (const sequence of model.sequences) {\n    while (true) {\n      let matched = false\n\n      if (sequence.type === 'random') {\n        shuffle(sequence.rules)\n      }\n\n      for (const rule of sequence.rules) {\n        matched = applySequenceRule(model, sequence, rule, matched)\n      }\n\n      if (!matched) break\n    }\n  }\n\n  return model\n}\n\nexport function slowGenerate(opts: Model, callback: ModelCallback, onDone?: ModelCallback) {\n  let INC = 1000 / 60\n  let NEXT = 0\n\n  validateGrid(opts)\n  const model: ValidModel = { ...opts, ...processSequences(opts.rules), count: 0, rule: -1, id: ++ID }\n\n  NEXT = Date.now() + INC\n\n  const render = async () => {\n    if (Date.now() >= NEXT) {\n      callback(model)\n      await delay(0)\n      NEXT += INC\n    }\n  }\n\n  const runner = async () => {\n    for (const sequence of model.sequences) {\n      model.rule++\n      while (ID === model.id) {\n        let matched = false\n\n        if (sequence.type === 'random') {\n          shuffle(sequence.rules)\n        }\n\n        for (const rule of sequence.rules) {\n          if (ID !== model.id) return\n          matched = applySequenceRule(model, sequence, rule, matched)\n          await render()\n\n          if (sequence.type !== 'one' && matched) break\n        }\n\n        if (!matched) break\n      }\n    }\n\n    callback(model)\n    onDone?.(model)\n    stop()\n  }\n\n  const stop = () => {\n    model.rule = -1\n    model.id = -1\n  }\n\n  runner()\n\n  return { stop }\n}\n\nfunction delay(ms = 0) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction applySequenceRule(model: ValidModel, seq: Sequence, rule: Rule, matched: boolean) {\n  if (rule.steps.max && !rule.steps.all && rule.steps.count >= rule.steps.max) {\n    return matched || false\n  }\n\n  model.count++\n\n  let matches = findMatches(model, rule)\n  if (matches.length === 0) return matched || false\n\n  if (rule.steps.all) {\n    for (const match of matches) {\n      applyRule(model, rule, match)\n    }\n\n    model.count += matches.length\n    rule.steps.count = Infinity\n  } else {\n    const random = Math.floor(Math.random() * matches.length)\n    const match = matches[random]\n    rule.steps.count++\n    applyRule(model, rule, match)\n\n    if (seq.type === 'one') {\n      return true\n    }\n  }\n\n  return true\n}\n\nexport function processSequences(inputs: string[], errors = true) {\n  const sequences: ValidModel['sequences'] = []\n  const unions: ValidModel['unions'] = {}\n\n  for (const rules of inputs) {\n    if (rules.toLowerCase().startsWith('union') || rules.toLowerCase().startsWith('symbol')) {\n      const [, ...input] = rules.split(' ')\n      if (!input.length) continue\n\n      const [symbol, union] = input\n        .join('')\n        .split('=')\n        .map((v) => v.replace(/\\s/g, ''))\n      if (!symbol || !union) continue\n\n      if (symbol.length > 1 && errors)\n        throw new Error(`Invalid union symbol: Must be only one character. ({SYMBOL}={UNION})`)\n      unions[symbol] = new Set(union.split(''))\n\n      continue\n    }\n\n    sequences.push(getSequences(rules, errors))\n  }\n\n  return { sequences, unions }\n}\n\nfunction getSequences(rules: string, errors = true): Sequence {\n  const seq: Sequence = { type: 'standard', rules: [] }\n\n  if (rules.toLowerCase().startsWith('one')) {\n    seq.type = 'one'\n    rules = rules.slice(3).trim()\n  }\n\n  if (rules.toLowerCase().startsWith('random')) {\n    seq.type = 'random'\n    rules = rules.slice(6).trim()\n  }\n\n  for (const input of expandRules(rules)) {\n    const [instruction, steps] = input\n      .replace(/\\s+/g, ' ')\n      .replace(/(\\s*)=(\\s*)/, '=')\n      .split(' ')\n    const pair = instruction.replace(/\\s/g, '').split('=')\n\n    if (pair[0] === pair[1]) continue\n\n    if (pair.length !== 2) {\n      if (errors) throw new Error(`Rules must follow format: {FROM}={TO}`)\n      pair.push('')\n    }\n\n    const rule: Rule = {\n      type: 'one',\n      from: pair[0],\n      to: pair[1],\n      steps: getSteps(steps, errors),\n    }\n\n    if (rule.steps.all) rule.type = 'all'\n\n    if (pair[0].length !== pair[1].length && errors) {\n      throw new Error(`{FROM} and {TO} patterns must be equal in length: ${instruction}`)\n    }\n\n    for (let c = 0; c < pair[0].length; c++) {\n      if ((pair[0][c] === '/' && pair[1][c] !== '/') || (pair[0][c] !== '/' && pair[1][c] === '/')) {\n        if (errors) throw new Error(`Step characters (/) must occur in the same positions: ${instruction}`)\n      }\n    }\n\n    seq.rules.push(rule)\n  }\n\n  return seq\n}\n\nfunction expandRules(rules: string) {\n  return rules.split(',').map((rule) => rule.trim())\n}\n\nfunction getSteps(input: string, errors = true): Steps {\n  const steps: Steps = { count: 0 }\n  if (!input) return steps\n\n  if (input.startsWith('#') === false) {\n    if (errors) throw new Error(`Steps must start with '#', (${input})`)\n    return steps\n  }\n\n  if (input === '#ALL') {\n    steps.all = true\n    return steps\n  }\n\n  if (input.includes('..')) {\n    const range = input.split('..')\n    const [from, to] = [Number(range[0]), Number(range[1])]\n\n    if (isNaN(from) || isNaN(to)) {\n      if (errors) throw new Error(`Step range must be formatted: #{FROM}..{TO}`)\n      return steps\n    }\n\n    if (from > to || from < 0 || to < 0) {\n      if (errors) throw new Error(`Invalid step range: {FROM} must be below {TO} and both values must be above 0`)\n      return steps\n    }\n\n    steps.max = getRandom(from, to)\n    steps.seed = () => getRandom(from, to)\n    return steps\n  }\n\n  const value = Number(input.slice(1))\n  if (isNaN(value)) {\n    if (errors) throw new Error(`Invalid step: Must follow be one of: #ALL, #{int}, #{from}..{to}`)\n    return steps\n  }\n\n  steps.max = value\n  return steps\n}\n\nfunction getRandom(from: number, to: number) {\n  return Math.floor(Math.random() * (to - from + 1) + from)\n}\n\nfunction shuffle(list: any[]) {\n  for (let i = list.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    const temp = list[i]\n    list[i] = list[j]\n    list[j] = temp\n  }\n\n  return list\n}\n", "import { Model } from '../src'\nimport { generate, slowGenerate } from '../src/generate'\n\ntype Opts = {\n  type: 'slow' | 'fast'\n  model: Model\n}\n\nonmessage = ({ data: { model, type } }: MessageEvent<Opts>) => {\n  if (type === 'slow') {\n    slowGenerate(model, (model) => postMessage(model))\n    return\n  }\n\n  const result = generate(model)\n  postMessage(result)\n}\n"],
  "mappings": "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",
  "names": []
}
